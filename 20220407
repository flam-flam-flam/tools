1、使用feign需要添加什么注解？
feign客户端位于spring-cloud-starter-feign软件包中，要启用它，我们必须使用@EnableFeignClients注解。要是用它，我们只需使用@FeignClient注解一个接口，然后将其自动连接到控制器中即可



2、ribbon配置
connectionTimeout，连接超时时间
ReadTimeout，读取超时时间
okToRetryonAllOperations,对所有操作请求都进行重试
maxautoretriesNextserver 切换服务器实例的重试次数
maxautoreties对当前实例的重试次数
listofservers无服务发现时，列表

3、zuul网关filter
PRE 在请求被路由之前调用，可用于身份验证，选择请求的服务器，记录调试信息
ROUTING这种过滤器将请求路由到微服务
post这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的http header手机统计信息和指标，并发送给客户端
error：在其他阶段发生错误是执行该过滤器

4、feign和ribbon超时时间设置，谁优先级高
feign优先级高于ribbon


5、java守护线程
在java中通常有两种线程：用户线程和守护线程，如果不设置线程属性，那么默认为是用户线程。当应用中所有的线程都是守护线程的时候，应用就可以结束了。如果还有一个或以上的非守护线程，应用就不会退出。守护线程是一种特殊的线程，在后台默默地完成一些系统性的服务，垃圾回收线程就是守护线程

6、java 引用类型
强引用，java中默认声明的就是强引用，垃圾回收器永远不会回收被引用的对象，哪怕内存不足时，jvm也会直接抛出outofMemoryError，也不会去回收强引用的对象。如果想中断强引用和对象之间的联系，可以将强引用赋值为null，这样jvm就可以适时的回收对象了
软引用，在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象。常常被用来实现缓存技术
弱引用的引用强度比软引用要更弱一些，屋内内存是否足够，只要jvm开始进行垃圾回收，娜美被弱引用关联的对象都会被回收。

虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。虚引用必须要和ReferenceQueue引用队列一起使用，他的作用在于跟踪垃圾回收过程。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动(引用队列由referencequeue类表示



7、springboot如何加载自定义的配置文件
方法一，通过@PropertySource注解
方法二，实现environmentpostprocessor接口，在postprocessEnvironment使用properties.load方法中加载自定义配置文件。还要在spring.factories中启用我们的自定义环境处理类org.springframework.boot.env.enviromentPostProcessor=实现类



8、springboot常用注解
1)springbootApplication是一个复合注解，包含了@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan这三个注解。  		  
	springbootconfiguration继承自@Configuration；	EnableAutoConfiguration注解，开启自动配置功能，将所有符合条件的Configuration配置都加载到当前SpringBoot创建并使用的Ioc容器，借助于Spring框架原有的一个工具类：springfactoriesLoader的支持。
	@componentScan,主要用于组件扫描和自动装配，我们可以通过basepackages等属性指定@ComponentScan自动扫描的范围，默认不指定，从@ComponentScan所在类的package进行扫描。
	
2）Controller控制器，处理http请求
3）RestController，复合注解相当于@ResponseBody+@Controller合在一起的作用，RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式
4）@RequestParam用来处理content-type为application/x-www-form-urlencoded,content-type默认为该属性，获取请求参数的值。请求示例：http://localhost:8080/User/getUser?uid=123
5）@RequestBody接收的参数是来自requestBody，即请求体，一般用于处理非content-type；application/x-www-form-urlencoded编码格式的数据，如application/json
6)RequestMapping是spring web应用程序中最常被用到的注解之一。这个注解会将HTTP请求映射到处理方法上
7）GetMapping用于将http get请求映射到特定处理程序的方法 注解.@RequestMapping(value="/say“，method=requestMethod.GET)等价于：@GetMapping(value="/say")
8）@postmapping用于将http post请求映射到特定处理程序的方法注解
9）@PathVariable：获取url中的数据
10）@RequestHeader 把request请求header部分的值绑定到方法的参数上
11）@Repository，DAO层注解
12）@Service用于标注服务层组件，标识定义一个bean，名称默认为当前的类名，首字母小写。 还可以通过@Service("serviceBeanId")或@Service(value="serviceBeanId")指定
13）@scope作用域注解，作用在类上和方法上，用来配置spring bean的作用域，它标识bean的作用域。 singleton单例模式：全局有且只有一个实例；prototype原型模式：每次获取bean的时候会有一个新的实例； request标识针对每一次http请求都会产生一个新的bean，同时该bean仅在当前http request内有效； session作用域标识针对每一个http请求都会产生一个新的bean，同时改bean尽在当前http session内有效
14）@Entity实体类注解
15）@bean产生一个bean的方法，明确地指示了一种方法，产生一个bean的方法，并且交给spring容器管理。
16）@autowire自动导入，作用在构造函数、方法、方法参数、类字段
17）@component
18）@propertysource
19）@importResource导入xml配置文件
20）@import导入额外的配置信息，可以导入带有@configuration直接的配置类
21）transactional事务注解。在spring中，事务有两种实现方式，编程时事务管理和声明式事务管理。
    编程式事务管理使用transactionTemplate；声明式事务管理建立在AOP之上的，其本质是对方法前后进行拦截，然后再目标方法开始之前创建或者加入一个事务，再执行万目标方法之后根据执行情况提交或者回滚事务，通过Transactional就可以进行事务操作
22）controllerAdvice 统一异常处理
23）@ExceptionHandler注解声明异常处理方法



9、mybatis的动态sql标签
if/where/trim/chooose/when/otherwise/foreach

10、http和https的区别
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议

11、https的工作流程如下
1）tcp三次同步握手
2）客户端发送client_hello
3）服务器发送client_hello，tls协议版本version、加密套件、压缩算法、随机数
4）服务器发送证书
5）服务端发送server key Exchange（加密算法，不一定发送，RSA算法就进行该流程）
6）服务器发送server hello done
7）客户端发送自己的公钥参数，加密算法
8）服务端发送new session ticket 服务器给客户端一个会话，用处就是在一段时间之内，双方都以协商的密钥进行通信
9）服务端发送change_cipher_spec，告诉客户端密钥有效
10）服务端发送encrypted_handshake_message客诉客户端可以正常加解密
11）完成密钥协商，开始发送数据
12）完成数据发送。

12、https证书内容都包含哪些内容
电子签证机关的信息，公钥用户信息、公钥，权威机构的签字和有效期，签发日期等



13、jvm的内存结构大概分为
1）堆，线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。 堆的作用是存放对象实例和数组。从结构上来看，可以分为新生代和老年代。而老年大又可以分为Eden空间、From Survivor空间、To survivor空间。所有新生成的对象首先都是放在新生代的，需要注意，survivor两个区是对称的，没有先后关系，所以同一个区中可能同时存在从Eden复制过来的对象和从前一个survivor复制过来的对象，而复制到老年代的只有从第一个survivor去过来的对象，而且survivor区总有一个是空的。 -Xms设置堆的最小空间大小。 -Xmx设置堆的最大空间大小。 -XX:NewSize设置新生代最小空间大小。 -XX:MaxNewSize设置新生代最小空间大小。此区域是垃圾回收的主要操作区域。

2）方法区：线程共享。 存储类信息、常量、静态变量，即时编译器编译后的代码。控制参数-XX:PermSize设置最小空间 -XXMaxPermSize设置最大空间
3）方法栈：线程私有。存储局部变量表，操作栈、动态链接、方法出口，对象指针。-Xss控制每个线程栈的大小
4）本地方法栈：线程私有。为虚拟机使用到的Native方法服务。和方法栈（虚拟机栈一样）本地方法栈区域也会抛出StackOverflowError（尾递归、死循环）和OutOfMemoryError异常
5）程序技术器：线程私有，它可以看做是当前线程所执行的字节码的行号指示器，指向下一条要执行的指令。此内存区域是唯一一个在java虚拟机规范中没有规定任何outofmemoryerror情况的区域。


14、mysql事务隔离级别
1）读未提交。未加锁，性能最高，a事务update，事务B查询。 A事务回滚，事务B得到的就是脏数据
2）读提交。就是一个事务只能读到其他事务已经提交过的数据（oracle默认隔离级别）。事务Aupdate，事务查询到之前的数据，事务A提交，事务B再查，查到更新后的数据，在同一事务B中，不同时刻同样的查询条件，查询出来的记录内容不一样。事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别
3）可重复读。是指事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。
实现方式：mysql采用了MVVC（多版本并发控制）的方式。每次读提交都会生成一个快照。 当前事务内的更新，可以读到；版本为提交，不能读到；版本已提交，但是却在创建快照创建后提交的，不能读到，版本已提交，且在快照创建前提交的，可以读到。
并发写的问题，两个事务，对同一条数据做修改，通过行锁解决。解决幻读，行锁+间隙锁（可重复读可以解决幻读问题，间隙锁就是数字区间锁）
4）串行化 后一个事务的执行必须等待前一个事务结束

15、mysql索引类型fulltext，hash，btree。种类：普通索引； 唯一索引； 主键索引；组合索引；全文索引

16、索引失效的集中情况
1）有or但是不是所有条件都有索引
2）复合索引未用左列字段
3）like以%开头
4）where中索引列有运算
5）where中索引列使用了函数
6）mysql觉得全表扫描更快时（数据少）
7）需要类型转换

17、java基本类型：byte、short、int、long、double、float、char、boolean，对应包装类型Byte、Short。Integer、Long、Double、Float、Character、Boolean。基本类型转化为包装类型叫装箱，反之拆箱。

18、基本类型和包装类型的区别
1）包装类型可以为null，而基本类型不可以。为什么pojo的属性必须要用包装类型呢。数据库的查询结果可能是null，如果使用基本类型的话，因为要自动拆箱，就会抛出空指针异常。
2）包装类型可用于泛型，而基本类型不可以。因为是泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是object类及其子类。
3）基本类型比包装类型更高效，基本类型在栈中直接存储值，而包装类型则存储的是对重的引用（占用更多的内存空间）。
4）两个包装类型的值可以相同，但却不相等。 两个包装类型在使用“==”进行判断的时候，判断的是器指向的地址是否相等。而equals的输出结果为true，因为equals方法内部比较的是两个int值是否相等。
5）自动装箱和自动拆箱。当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。

