1、使用feign需要添加什么注解？
feign客户端位于spring-cloud-starter-feign软件包中，要启用它，我们必须使用@EnableFeignClients注解。要是用它，我们只需使用@FeignClient注解一个接口，然后将其自动连接到控制器中即可



2、ribbon配置
connectionTimeout，连接超时时间
ReadTimeout，读取超时时间
okToRetryonAllOperations,对所有操作请求都进行重试
maxautoretriesNextserver 切换服务器实例的重试次数
maxautoreties对当前实例的重试次数
listofservers无服务发现时，列表

3、zuul网关filter
PRE 在请求被路由之前调用，可用于身份验证，选择请求的服务器，记录调试信息
ROUTING这种过滤器将请求路由到微服务
post这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的http header手机统计信息和指标，并发送给客户端
error：在其他阶段发生错误是执行该过滤器

4、feign和ribbon超时时间设置，谁优先级高
feign优先级高于ribbon


5、java守护线程
在java中通常有两种线程：用户线程和守护线程，如果不设置线程属性，那么默认为是用户线程。当应用中所有的线程都是守护线程的时候，应用就可以结束了。如果还有一个或以上的非守护线程，应用就不会退出。守护线程是一种特殊的线程，在后台默默地完成一些系统性的服务，垃圾回收线程就是守护线程

6、java 引用类型
强引用，java中默认声明的就是强引用，垃圾回收器永远不会回收被引用的对象，哪怕内存不足时，jvm也会直接抛出outofMemoryError，也不会去回收强引用的对象。如果想中断强引用和对象之间的联系，可以将强引用赋值为null，这样jvm就可以适时的回收对象了
软引用，在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象。常常被用来实现缓存技术
弱引用的引用强度比软引用要更弱一些，屋内内存是否足够，只要jvm开始进行垃圾回收，娜美被弱引用关联的对象都会被回收。

虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。虚引用必须要和ReferenceQueue引用队列一起使用，他的作用在于跟踪垃圾回收过程。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动(引用队列由referencequeue类表示



7、springboot如何加载自定义的配置文件
方法一，通过@PropertySource注解
方法二，实现environmentpostprocessor接口，在postprocessEnvironment使用properties.load方法中加载自定义配置文件。还要在spring.factories中启用我们的自定义环境处理类org.springframework.boot.env.enviromentPostProcessor=实现类



8、springboot常用注解
1)springbootApplication是一个复合注解，包含了@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan这三个注解。  		  
	springbootconfiguration继承自@Configuration；	EnableAutoConfiguration注解，开启自动配置功能，将所有符合条件的Configuration配置都加载到当前SpringBoot创建并使用的Ioc容器，借助于Spring框架原有的一个工具类：springfactoriesLoader的支持。
	@componentScan,主要用于组件扫描和自动装配，我们可以通过basepackages等属性指定@ComponentScan自动扫描的范围，默认不指定，从@ComponentScan所在类的package进行扫描。
	
2）Controller控制器，处理http请求
3）RestController，复合注解相当于@ResponseBody+@Controller合在一起的作用，RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式
4）@RequestParam用来处理content-type为application/x-www-form-urlencoded,content-type默认为该属性，获取请求参数的值。请求示例：http://localhost:8080/User/getUser?uid=123
5）@RequestBody接收的参数是来自requestBody，即请求体，一般用于处理非content-type；application/x-www-form-urlencoded编码格式的数据，如application/json
6)RequestMapping是spring web应用程序中最常被用到的注解之一。这个注解会将HTTP请求映射到处理方法上
7）GetMapping用于将http get请求映射到特定处理程序的方法 注解.@RequestMapping(value="/say“，method=requestMethod.GET)等价于：@GetMapping(value="/say")
8）@postmapping用于将http post请求映射到特定处理程序的方法注解
9）@PathVariable：获取url中的数据
10）@RequestHeader 把request请求header部分的值绑定到方法的参数上
11）@Repository，DAO层注解
12）@Service用于标注服务层组件，标识定义一个bean，名称默认为当前的类名，首字母小写。 还可以通过@Service("serviceBeanId")或@Service(value="serviceBeanId")指定
13）@scope作用域注解，作用在类上和方法上，用来配置spring bean的作用域，它标识bean的作用域。 singleton单例模式：全局有且只有一个实例；prototype原型模式：每次获取bean的时候会有一个新的实例； request标识针对每一次http请求都会产生一个新的bean，同时该bean仅在当前http request内有效； session作用域标识针对每一个http请求都会产生一个新的bean，同时改bean尽在当前http session内有效
14）@Entity实体类注解
15）@bean产生一个bean的方法，明确地指示了一种方法，产生一个bean的方法，并且交给spring容器管理。
16）@autowire自动导入，作用在构造函数、方法、方法参数、类字段
17）@component
18）@propertysource
19）@importResource导入xml配置文件
20）@import导入额外的配置信息，可以导入带有@configuration直接的配置类
21）transactional事务注解。在spring中，事务有两种实现方式，编程时事务管理和声明式事务管理。
    编程式事务管理使用transactionTemplate；声明式事务管理建立在AOP之上的，其本质是对方法前后进行拦截，然后再目标方法开始之前创建或者加入一个事务，再执行万目标方法之后根据执行情况提交或者回滚事务，通过Transactional就可以进行事务操作
22）controllerAdvice 统一异常处理
23）@ExceptionHandler注解声明异常处理方法
